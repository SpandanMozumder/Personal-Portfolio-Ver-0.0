'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var core = require('@react-pdf-viewer/core');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var HIGHLIGHT_LAYER_ATTR = 'data-highlight-text-layer';
var HIGHLIGHT_PAGE_ATTR = 'data-highlight-text-page';

var normalizeRotation = function (rotation) {
    return rotation >= 0 ? rotation : 360 + rotation;
};
var getCssProperties = function (area, rotation) {
    var r = normalizeRotation(rotation);
    switch (r) {
        case 90:
            return {
                height: area.width + "%",
                position: 'absolute',
                right: area.top + "%",
                top: area.left + "%",
                width: area.height + "%",
            };
        case 180:
            return {
                bottom: area.top + "%",
                height: area.height + "%",
                position: 'absolute',
                right: area.left + "%",
                width: area.width + "%",
            };
        case 270:
            return {
                height: area.width + "%",
                position: 'absolute',
                left: area.top + "%",
                bottom: area.left + "%",
                width: area.height + "%",
            };
        case 0:
        case 360:
        default:
            return {
                height: area.height + "%",
                position: 'absolute',
                top: area.top + "%",
                left: area.left + "%",
                width: area.width + "%",
            };
    }
};
var transformArea = function (area, rotation) {
    var r = normalizeRotation(rotation);
    switch (r) {
        case 90:
            return {
                height: area.width,
                left: area.top,
                pageIndex: area.pageIndex,
                top: 100 - area.width - area.left,
                width: area.height,
            };
        case 180:
            return {
                height: area.height,
                left: 100 - area.width - area.left,
                pageIndex: area.pageIndex,
                top: 100 - area.height - area.top,
                width: area.width,
            };
        case 270:
            return {
                height: area.width,
                left: 100 - area.height - area.top,
                pageIndex: area.pageIndex,
                top: area.left,
                width: area.height,
            };
        case 0:
        case 360:
        default:
            return area;
    }
};

var HighlightRect = function (_a) {
    var area = _a.area, rotation = _a.rotation;
    return (React__namespace.createElement("div", { className: 'rpv-highlight-rect', style: getCssProperties(area, rotation) }));
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var SelectionState = (function () {
    function SelectionState() {
    }
    return SelectionState;
}());
var NoSelectionState = (function (_super) {
    __extends(NoSelectionState, _super);
    function NoSelectionState() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoSelectionState;
}(SelectionState));
var SelectingState = (function (_super) {
    __extends(SelectingState, _super);
    function SelectingState() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SelectingState;
}(SelectionState));
var SelectedState = (function (_super) {
    __extends(SelectedState, _super);
    function SelectedState(selectedText, highlightAreas, selectionData, selectionRegion) {
        var _this = _super.call(this) || this;
        _this.selectedText = selectedText;
        _this.selectionData = selectionData;
        _this.selectionRegion = selectionRegion;
        _this.highlightAreas = highlightAreas;
        return _this;
    }
    return SelectedState;
}(SelectionState));
var HighlightState = (function (_super) {
    __extends(HighlightState, _super);
    function HighlightState(selectedText, highlightAreas, selectionData, selectionRegion) {
        var _this = _super.call(this) || this;
        _this.selectedText = selectedText;
        _this.selectionData = selectionData;
        _this.selectionRegion = selectionRegion;
        _this.highlightAreas = highlightAreas;
        return _this;
    }
    return HighlightState;
}(SelectionState));
var NO_SELECTION_STATE = new NoSelectionState();
var SELECTING_STATE = new SelectingState();

var useRotation = function (store) {
    var _a = React__namespace.useState(store.get('rotation') || 0), rotation = _a[0], setRotation = _a[1];
    var handleRotationChanged = function (currentRotation) { return setRotation(currentRotation); };
    React__namespace.useEffect(function () {
        store.subscribe('rotation', handleRotationChanged);
        return function () {
            store.unsubscribe('rotation', handleRotationChanged);
        };
    }, []);
    return { rotation: rotation };
};

var HighlightAreaList = function (_a) {
    var pageIndex = _a.pageIndex, renderHighlightContent = _a.renderHighlightContent, renderHighlightTarget = _a.renderHighlightTarget, renderHighlights = _a.renderHighlights, store = _a.store;
    var _b = React__namespace.useState(store.get('selectionState')), selectionState = _b[0], setSelectionState = _b[1];
    var rotation = useRotation(store).rotation;
    var handleSelectionState = function (s) { return setSelectionState(s); };
    var cancel = function () {
        window.getSelection().removeAllRanges();
        store.update('selectionState', NO_SELECTION_STATE);
    };
    React__namespace.useEffect(function () {
        store.subscribe('selectionState', handleSelectionState);
        return function () {
            store.unsubscribe('selectionState', handleSelectionState);
        };
    }, []);
    var listAreas = selectionState instanceof HighlightState
        ? selectionState.highlightAreas.filter(function (s) { return s.pageIndex === pageIndex; })
        : [];
    return (React__namespace.createElement(React__namespace.Fragment, null,
        renderHighlightTarget && (selectionState instanceof SelectedState) && (selectionState.selectionRegion.pageIndex === pageIndex) && (renderHighlightTarget({
            highlightAreas: selectionState.highlightAreas,
            selectedText: selectionState.selectedText,
            selectionRegion: selectionState.selectionRegion,
            selectionData: selectionState.selectionData,
            cancel: cancel,
            toggle: function () {
                store.update('selectionState', new HighlightState(selectionState.selectedText, selectionState.highlightAreas, selectionState.selectionData, selectionState.selectionRegion));
                window.getSelection().removeAllRanges();
            },
        })),
        renderHighlightContent && (selectionState instanceof HighlightState) && (selectionState.selectionRegion.pageIndex === pageIndex) && (renderHighlightContent({
            highlightAreas: selectionState.highlightAreas,
            selectedText: selectionState.selectedText,
            selectionRegion: selectionState.selectionRegion,
            selectionData: selectionState.selectionData,
            cancel: cancel,
        })),
        listAreas.length > 0 && (React__namespace.createElement("div", null, listAreas.map(function (area, idx) { return React__namespace.createElement(HighlightRect, { key: idx, area: area, rotation: rotation }); }))),
        renderHighlights && renderHighlights({
            pageIndex: pageIndex,
            rotation: rotation,
            getCssProperties: getCssProperties,
        })));
};

var getRectFromOffsets = function (textDiv, startOffset, endOffset) {
    var clonedEle = textDiv.cloneNode(true);
    textDiv.parentNode.appendChild(clonedEle);
    var firstChild = clonedEle.firstChild;
    var range = new Range();
    range.setStart(firstChild, startOffset);
    range.setEnd(firstChild, endOffset);
    var wrapper = document.createElement('span');
    range.surroundContents(wrapper);
    var rect = wrapper.getBoundingClientRect();
    clonedEle.parentNode.removeChild(clonedEle);
    return rect;
};

var getTextFromOffsets = function (textLayerDiv, startDivIdx, startOffset, endDivIdx, endOffset) {
    var nodes = [].slice.call(textLayerDiv.children);
    if (startDivIdx < endDivIdx) {
        var startDivText = nodes
            .slice(startDivIdx, startDivIdx + 1)
            .map(function (node) { return node.textContent.substring(startOffset).trim(); })
            .join(' ');
        var middleDivText = nodes
            .slice(startDivIdx + 1, endDivIdx)
            .map(function (node) { return node.textContent.trim(); })
            .join(' ');
        var endDivText = nodes
            .slice(endDivIdx, endDivIdx + 1)
            .map(function (endDiv) {
            return endDiv.textContent.substring(0, endOffset || endDiv.textContent.length);
        })
            .join(' ');
        return startDivText + " " + middleDivText + " " + endDivText;
    }
    else {
        var div = nodes[startDivIdx];
        return div.textContent
            .substring(startOffset, endOffset || div.textContent.length)
            .trim();
    }
};

var SelectionRange;
(function (SelectionRange) {
    SelectionRange["SameDiv"] = "SameDiv";
    SelectionRange["DifferentDivs"] = "DifferentDivs";
    SelectionRange["DifferentPages"] = "DifferentPages";
})(SelectionRange || (SelectionRange = {}));
var SelectionRange$1 = SelectionRange;

var Tracker = function (_a) {
    var store = _a.store;
    var rotation = useRotation(store).rotation;
    var pagesRef = React__namespace.useRef(null);
    var _b = React__namespace.useState(false), arePagesFound = _b[0], setPagesFound = _b[1];
    var handlePagesContainer = function (getPagesContainer) {
        var ele = getPagesContainer();
        pagesRef.current = ele;
        setPagesFound(!!ele);
    };
    var onMouseUpHandler = function () {
        var selection = document.getSelection();
        var selectionState = store.get('selectionState');
        var hasSelection = (selectionState === NO_SELECTION_STATE || selectionState === SELECTING_STATE) &&
            selection.rangeCount > 0 && selection.toString() !== '';
        if (!hasSelection) {
            return;
        }
        var range = selection.getRangeAt(0);
        var startDiv = range.startContainer.parentNode;
        var parentEndContainer = range.endContainer.parentNode;
        var shouldIgnoreEndContainer = (parentEndContainer instanceof HTMLElement) && parentEndContainer.hasAttribute(HIGHLIGHT_LAYER_ATTR);
        var endDiv, endOffset;
        if (shouldIgnoreEndContainer && range.endOffset == 0) {
            endDiv = range.endContainer.previousSibling;
            endOffset = endDiv.textContent.length;
        }
        else if (shouldIgnoreEndContainer) {
            endDiv = range.endContainer;
            endOffset = range.endOffset;
        }
        else {
            endDiv = parentEndContainer;
            endOffset = range.endOffset;
        }
        if (!(startDiv instanceof HTMLElement) || !(endDiv instanceof HTMLElement)) {
            return;
        }
        var startPageIdx = parseInt(startDiv.getAttribute(HIGHLIGHT_PAGE_ATTR), 10);
        var endPageIdx = parseInt(endDiv.getAttribute(HIGHLIGHT_PAGE_ATTR), 10);
        var startTextLayer = startDiv.parentElement;
        var endTextLayer = endDiv.parentElement;
        var startPageRect = startTextLayer.getBoundingClientRect();
        var startDivSiblings = [].slice.call(startTextLayer.querySelectorAll("[" + HIGHLIGHT_PAGE_ATTR + "]"));
        var startDivIdx = startDivSiblings.indexOf(startDiv);
        var endPageRect = endTextLayer.getBoundingClientRect();
        var endDivSiblings = [].slice.call(endTextLayer.querySelectorAll("[" + HIGHLIGHT_PAGE_ATTR + "]"));
        var endDivIdx = endDivSiblings.indexOf(endDiv);
        var rangeType = SelectionRange$1.DifferentPages;
        switch (true) {
            case (startPageIdx === endPageIdx && startDivIdx === endDivIdx):
                rangeType = SelectionRange$1.SameDiv;
                break;
            case (startPageIdx === endPageIdx && startDivIdx < endDivIdx):
                rangeType = SelectionRange$1.DifferentDivs;
                break;
            default:
                rangeType = SelectionRange$1.DifferentPages;
                break;
        }
        var getRectBetween = function (min, max, eleArray) { return Array(max - min + 1).fill(0)
            .map(function (_, i) { return eleArray[min + i].getBoundingClientRect(); }); };
        var highlightAreas = [];
        switch (rangeType) {
            case SelectionRange$1.SameDiv:
                var rect = getRectFromOffsets(startDiv, range.startOffset, endOffset);
                highlightAreas = [{
                        height: rect.height * 100 / startPageRect.height,
                        left: (rect.left - startPageRect.left) * 100 / startPageRect.width,
                        pageIndex: startPageIdx,
                        top: (rect.top - startPageRect.top) * 100 / startPageRect.height,
                        width: rect.width * 100 / startPageRect.width,
                    }];
                break;
            case SelectionRange$1.DifferentDivs:
                highlightAreas = [getRectFromOffsets(startDiv, range.startOffset, startDiv.textContent.length)]
                    .concat(getRectBetween(startDivIdx + 1, endDivIdx - 1, startDivSiblings))
                    .concat([getRectFromOffsets(endDiv, 0, endOffset)])
                    .map(function (rect) {
                    return {
                        height: rect.height * 100 / startPageRect.height,
                        left: (rect.left - startPageRect.left) * 100 / startPageRect.width,
                        pageIndex: startPageIdx,
                        top: (rect.top - startPageRect.top) * 100 / startPageRect.height,
                        width: rect.width * 100 / startPageRect.width,
                    };
                });
                break;
            case SelectionRange$1.DifferentPages:
                var startAreas = [getRectFromOffsets(startDiv, range.startOffset, startDiv.textContent.length)]
                    .concat(getRectBetween(startDivIdx + 1, startDivSiblings.length - 1, startDivSiblings))
                    .map(function (rect) {
                    return {
                        height: rect.height * 100 / startPageRect.height,
                        left: (rect.left - startPageRect.left) * 100 / startPageRect.width,
                        pageIndex: startPageIdx,
                        top: (rect.top - startPageRect.top) * 100 / startPageRect.height,
                        width: rect.width * 100 / startPageRect.width,
                    };
                });
                var endAreas = getRectBetween(0, endDivIdx - 1, endDivSiblings)
                    .concat([getRectFromOffsets(endDiv, 0, endOffset)])
                    .map(function (rect) {
                    return {
                        height: rect.height * 100 / endPageRect.height,
                        left: (rect.left - endPageRect.left) * 100 / endPageRect.width,
                        pageIndex: endPageIdx,
                        top: (rect.top - endPageRect.top) * 100 / endPageRect.height,
                        width: rect.width * 100 / endPageRect.width,
                    };
                });
                highlightAreas = startAreas.concat(endAreas);
                break;
        }
        var selectedText = '';
        switch (rangeType) {
            case SelectionRange$1.SameDiv:
                selectedText = getTextFromOffsets(startTextLayer, startDivIdx, range.startOffset, startDivIdx, endOffset);
                break;
            case SelectionRange$1.DifferentDivs:
                selectedText = getTextFromOffsets(startTextLayer, startDivIdx, range.startOffset, endDivIdx, endOffset);
                break;
            case SelectionRange$1.DifferentPages:
                var startText = getTextFromOffsets(startTextLayer, startDivIdx, range.startOffset, startDivSiblings.length);
                var endText = getTextFromOffsets(endTextLayer, 0, 0, endDivIdx, endOffset);
                selectedText = startText + "\n" + endText;
                break;
        }
        var selectionRegion;
        if (highlightAreas.length > 0) {
            selectionRegion = highlightAreas[highlightAreas.length - 1];
        }
        else {
            var endDivRect = endDiv.getBoundingClientRect();
            selectionRegion = {
                height: endDivRect.height * 100 / endPageRect.height,
                left: (endDivRect.left - endPageRect.left) * 100 / endPageRect.width,
                pageIndex: endPageIdx,
                top: (endDivRect.top - endPageRect.top) * 100 / endPageRect.height,
                width: endDivRect.width * 100 / endPageRect.width,
            };
        }
        var selectionData = {
            startPageIndex: startPageIdx - 1,
            endPageIndex: endPageIdx - 1,
            startOffset: range.startOffset,
            startDivIndex: startDivIdx,
            endOffset: endOffset,
            endDivIndex: endDivIdx
        };
        store.update('selectionState', new SelectedState(selectedText, highlightAreas.map(function (area) { return transformArea(area, rotation); }), selectionData, selectionRegion));
    };
    React__namespace.useEffect(function () {
        var ele = pagesRef.current;
        if (!ele) {
            return;
        }
        ele.addEventListener('mouseup', onMouseUpHandler);
        return function () {
            ele.removeEventListener('mouseup', onMouseUpHandler);
        };
    }, [arePagesFound, rotation]);
    React__namespace.useEffect(function () {
        store.subscribe('getPagesContainer', handlePagesContainer);
        return function () {
            store.unsubscribe('getPagesContainer', handlePagesContainer);
        };
    }, []);
    return React__namespace.createElement(React__namespace.Fragment, null);
};

var highlightPlugin = function (props) {
    var store = React__namespace.useMemo(function () { return core.createStore({
        selectionState: NO_SELECTION_STATE,
    }); }, []);
    var renderViewer = function (props) {
        var currentSlot = props.slot;
        if (currentSlot.subSlot && currentSlot.subSlot.children) {
            currentSlot.subSlot.children = (React__namespace.createElement(React__namespace.Fragment, null,
                React__namespace.createElement(Tracker, { store: store }),
                currentSlot.subSlot.children));
        }
        return currentSlot;
    };
    var handleMouseDown = function (textLayerRender) { return function (e) {
        var pageRect = textLayerRender.ele.getBoundingClientRect();
        var selectionState = store.get('selectionState');
        if (selectionState instanceof SelectedState) {
            var mouseTop_1 = e.clientY - pageRect.top;
            var mouseLeft_1 = e.clientX - pageRect.left;
            var userClickedInsideArea = selectionState.highlightAreas
                .filter(function (area) { return area.pageIndex === textLayerRender.pageIndex; })
                .find(function (area) {
                var t = area.top * pageRect.height / 100;
                var l = area.left * pageRect.width / 100;
                var h = area.height * pageRect.height / 100;
                var w = area.width * pageRect.width / 100;
                return (t <= mouseTop_1) && (mouseTop_1 <= t + h) && (l <= mouseLeft_1) && (mouseLeft_1 <= l + w);
            });
            if (userClickedInsideArea) {
                window.getSelection().removeAllRanges();
                store.update('selectionState', NO_SELECTION_STATE);
            }
            else {
                store.update('selectionState', SELECTING_STATE);
            }
        }
        else {
            store.update('selectionState', NO_SELECTION_STATE);
        }
    }; };
    var onTextLayerRender = function (e) {
        var mouseDownHandler = handleMouseDown(e);
        var textEle = e.ele;
        switch (e.status) {
            case core.LayerRenderStatus.PreRender:
                textEle.removeEventListener('mousedown', mouseDownHandler);
                break;
            case core.LayerRenderStatus.DidRender:
                textEle.addEventListener('mousedown', mouseDownHandler);
                textEle.setAttribute(HIGHLIGHT_LAYER_ATTR, 'true');
                textEle.querySelectorAll('.rpv-core-text').forEach(function (span) { return span.setAttribute(HIGHLIGHT_PAGE_ATTR, "" + e.pageIndex); });
                break;
        }
    };
    var renderPageLayer = function (renderPageProps) { return (React__namespace.createElement(HighlightAreaList, { pageIndex: renderPageProps.pageIndex, renderHighlightContent: props && props.renderHighlightContent ? props.renderHighlightContent : null, renderHighlightTarget: props && props.renderHighlightTarget ? props.renderHighlightTarget : null, renderHighlights: props && props.renderHighlights ? props.renderHighlights : null, store: store })); };
    var jumpToHighlightArea = function (area) {
        var getPagesContainer = store.get('getPagesContainer');
        var getPageElement = store.get('getPageElement');
        if (!getPagesContainer || !getPageElement) {
            return;
        }
        var pagesEle = getPagesContainer();
        if (!pagesEle) {
            return;
        }
        var targetPage = getPageElement(area.pageIndex);
        pagesEle.scrollTop = targetPage.offsetTop + area.top * targetPage.clientHeight / 100 - pagesEle.offsetTop;
    };
    return {
        install: function (pluginFunctions) {
            store.update('getPageElement', pluginFunctions.getPageElement);
            store.update('getPagesContainer', pluginFunctions.getPagesContainer);
        },
        onViewerStateChange: function (viewerState) {
            store.update('rotation', viewerState.rotation);
            return viewerState;
        },
        jumpToHighlightArea: jumpToHighlightArea,
        onTextLayerRender: onTextLayerRender,
        renderPageLayer: renderPageLayer,
        renderViewer: renderViewer,
    };
};

var MessageIcon = function () { return (React__namespace.createElement(core.Icon, { size: 16 },
    React__namespace.createElement("path", { d: 'M23.5,17a1,1,0,0,1-1,1h-11l-4,4V18h-6a1,1,0,0,1-1-1V3a1,1,0,0,1,1-1h21a1,1,0,0,1,1,1Z' }),
    React__namespace.createElement("path", { d: 'M5.5 12L18.5 12' }),
    React__namespace.createElement("path", { d: 'M5.5 7L18.5 7' }))); };

exports.MessageIcon = MessageIcon;
exports.highlightPlugin = highlightPlugin;
